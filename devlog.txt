 
July 15: 6:57 AM
    Been working on this for a few days, decided to write stuff down here.
    Converted compilation system from cargo to .sh scripts
    Changed folder structure and names to be more intuitive (including renaming routines to verses)
    Added parsing of modification date info
    Started on culling unchanged routines from the routines-to-reload list
    
July 16:
    Failed to make culling unchanged routines work properly.
    
July 17:
    Made culling unchanged routines work, I guess? Need to test with actual runtime modification. Time for a UI!
    Init is called on all loaded verses, except ones that haven't beem modified.
    Exec is called in the main loop
    Started converting verse data vecs to be wrapped in a struct with safe getters/setters. This should ease the stress of ensuring they stay aligned.
    
July 21:
    Shit happened these last few days. RAII + unsafe code = pain. 
    Also, I was doing stupid things regarding process reloading. Selective reloading doesn't make sense, since the data would be cleared. Need Databases seperate from Processes. 
    Rewrote everything. Everything is beautiful now.

July 22:
    Designing how the databases work.
    
    Orchestrator starts up
        load_databases()
        hotload()
    
    hotload()
        Loads all the Processes
        Asks Processes what Databases they read from
        Asks Processes what Databases they write to
        Send Processes references to their Databases
    
    This way, when the orchestrator is reloaded, the data in the Databases will be persistent, while the Processes can change.
    If you need to change the data layout, you'll need to restart the orchestrator. Otherwise, just iterate it up.

August 3:
    Tonsilitis sucks.
    Figuring out my programming style for this project:
        Static functions are I/O functions. They do not change global state, but they may produce side effects such as print statements. For all intents and purposes though, they are 'pure' functions.
        Methods are not pure. They are managerial functions that change global state. 
    Refactoring happened today can you tell?
    
August 4:
    Removed all globals.
    Merged load_processes into hotload_processes. It was a mistake, fed by a subconscious desire to organize-by-concept. It is forbidden love.
    Changing pausable/unpausable distinction from a filesystem separation to melody separation.
    There are now three kinds of updates: Always, Only When Paused, and Only When Unpaused. They are executed in that order.
    Renamed processes back to routines, as I think that captures their intended use. Any data stored within them is temporary.
    Added ".data" and ".routine" filetypes to make loading them from directories easier.
    Added READMEs everywhere.
    
August 7:
    Removed ".data" filetype, as Rust can't seem to load custom named libraries at compile time. Perhaps this will change in the future.
        However, this may be a beneficial limitation, as 
        a) it ensues databases are differentiated per platform ("was this .data compiled for lin or win? hmm.."), and
        b) it makes linking routines to routines slightly more unpleasant. Which is good, as it should never be done anyway.
    Got the core of runtime database linking functioning! Routines can now modify database data! 
    
    As of this point, Worldsong is a working proof-of-concept!
    
August 9:
    Update phases are now PreUpdate, Update, Pause, and PostUpdate.
        Routines in the PreUpdate group are executed at the beginning of the frame.
        Routines in the Update group are executed when the application is unpaused. Otherwise, routines in the Paused group are run.
        Routines in the PostUpdate group are are executed at the end of the frame.
        
    Made exec() a method, to follow the code style guidelines.
    
August 10:
    Poked at how to represent statics being initialized lazily. Using an Option seems wasteful, and a bare pointer requires unsafe code everywhere.
        Thankfully, #rust pointed me to kimundi's terrifyingly beautiful lazy static macro, https://github.com/Kimundi/lazy-static.rs. 
        This looks like the answer.
        
August 14:
    Lazy static will still require unsafe code, so while it's elegant, I'd prefer to try something memory safe. Experimented with that today.
    Having routines be structs fixes the memory safety issue for the reference storage, but makes sending the data to the struct impossible 
        in the old way, since there's no struct instance.
    What might work better is to just have the references be stored in the orchestrator, as void* equivelents, dictated by _dbrequest, 
        and unsafely pass the references to the routines each frame. This would do the same thing as the original method, but the unsafe code 
        would be hidden from the routine writer.
        
August 15:
    Went with pointers. We're just going to macro-generate getters and setters.
    Why didn't I think of this before..
    
August 16:
    Thinking about 'art content'. The worldsong architecture is designed to have state data never be corrupted. 
    It accomplishes this with changable behaviours that work on known data.
        
        State data *could* be added at runtime in this architecture, but removal is unsafe.
        
        Because of this, dramatically changing art is an iffy proposition. It could be done, but how can we be sure adding/removing bones 
            won't ruin the physics simulation for that model? Do we make checks for each data access to ensue the proper contextual connections are removed? 
            Nonsense.
            
        The problem is, essentially, that by importing art assets we are working at different levels of detail. Blender and such are like the ASM of art:
            vertices and edges and polygons. They are within their own simulation, and when we edit them there, we have no guarentees their changes will
            make sense within the simulation they are being designed for.
            
        I see a solution to this being to create a fixed number of atomic types in the engine, which have native meaning in the simulation. 
            We can connect these together to create more complicated types, resulting in a domain-specific solution, rather than a low-level solution.
            
            Example: instead of modelling a character mesh, putting bones in, rigging, texturing, converting, importing, and fixin issues,
            I would create a character from a base skeleton hierarchy, define the physical properties of the volumes that describe the character's body, 
                describe how the mesh should aestetically wrap over the volumes (soft, hard, etc), and watch the machine generate physical variations for this description.
            To, say, add another limb to the character, I simply perform this process for the limb, and it's already *in the game*.
                All physical properties are simulated. There is no conversion. There is no difference between a 'limb' in the creation software and a 'limb' 
                    in the game. All descriptions are native and directly relate to gameplay.
                    
August 21:
    Database-linking macros implemented! Mostly. Still a few bugs to work out.
    
August 22:
    Database macros work! YESS :D
    Removed PreUpdate, Pause, and PostUpdate melodies. It's a micro optimization that only adds complexity at this point.
    Decided that routines and databases will be redistributed in text format to reduce cross-platform and cross-compiler-versioning issues. 
        A WorldsongSDK that bundles rustc and recompiles everything would make sense.
        