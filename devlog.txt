 
July 15: 6:57 AM
    Been working on this for a few days, decided to write stuff down here.
    Converted compilation system from cargo to .sh scripts
    Changed folder structure and names to be more intuitive (including renaming routines to verses)
    Added parsing of modification date info
    Started on culling unchanged routines from the routines-to-reload list
    
July 16:
    Failed to make culling unchanged routines work properly.
    
July 17:
    Made culling unchanged routines work, I guess? Need to test with actual runtime modification. Time for a UI!
    Init is called on all loaded verses, except ones that haven't beem modified.
    Exec is called in the main loop
    Started converting verse data vecs to be wrapped in a struct with safe getters/setters. This should ease the stress of ensuring they stay aligned.
    
July 21:
    Shit happened these last few days. RAII + unsafe code = pain. 
    Also, I was doing stupid things regarding process reloading. Selective reloading doesn't make sense, since the data would be cleared. Need Databases seperate from Processes. 
    Rewrote everything. Everything is beautiful now.

July 22:
    Designing how the databases work.
    
    Orchestrator starts up
        load_databases()
        hotload()
    
    hotload()
        Loads all the Processes
        Asks Processes what Databases they read from
        Asks Processes what Databases they write to
        Send Processes references to their Databases
    
    This way, when the orchestrator is reloaded, the data in the Databases will be persistent, while the Processes can change.
    If you need to change the data layout, you'll need to restart the orchestrator. Otherwise, just iterate it up.

August 3:
    Tonsilitis sucks.
    Figuring out my programming style for this project:
        Static functions are I/O functions. They do not change global state, but they may produce side effects such as print statements. For all intents and purposes though, they are 'pure' functions.
        Methods are not pure. They are managerial functions that change global state. 
    Refactoring happened today can you tell?
    
August 4:
    Removed all globals.
    Merged load_processes into hotload_processes. It was a mistake, fed by a subconscious desire to organize-by-concept. It is forbidden love.
    Changing pausable/unpausable distinction from a filesystem separation to melody separation.
    There are now three kinds of updates: Always, Only When Paused, and Only When Unpaused. They are executed in that order.
    Renamed processes back to routines, as I think that captures their intended use. Any data stored within them is temporary.
    Added ".data" and ".routine" filetypes to make loading them from directories easier.
    Added READMEs everywhere.
    
August 7:
    Removed ".data" filetype, as Rust can't seem to load custom named libraries at compile time. Perhaps this will change in the future.
        However, this may be a beneficial limitation, as 
        a) it ensues databases are differentiated per platform ("was this .data compiled for lin or win? hmm.."), and
        b) it makes linking routines to routines slightly more unpleasant. Which is good, as it should never be done anyway.
    Got the core of runtime database linking functioning! Routines can now modify database data! 
    
    As of this point, Worldsong is a working proof-of-concept!
    