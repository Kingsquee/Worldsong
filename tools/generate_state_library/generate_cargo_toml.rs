use rustc_serialize::{Decodable, Decoder};
use std::io::File;
use std::io::fs::PathExtensions;
use std::collections::HashMap;  
use toml;

use common::hierarchy;

pub fn exec(struct_src_dirs: &Vec<Path>) {
    println!("Generating the state's Cargo.toml.");
    
    let mut cargo_toml_text =
format!("#ATTENTION: This file is automatically generated. Don't modify it unless your life is terrible, or you wish it to be so.
[package]
name = \"state\"
version = \"0.0.1\"
authors = [ \"the ghost in the machine\" ]

[lib]
name = \"state\"
path = \"state.rs\"
crate_type = [\"dylib\"]
plugin = true

# Required by the kernel and scheduler
[dependencies.time]

# Required by all worldsong submodules
[dependencies.worldsong-common]
path = \"{common_dir}\"
", common_dir = hierarchy::get_common_src_dir().as_str().unwrap());
    
    for struct_src_dir in struct_src_dirs.iter() {
        // append the struct names and paths in the form: 
        // [dependencies.{struct_name}]
        // path = \"{struct_src_dir}/{struct_name}\"
        // with struct_name = struct_src_dir.filename_str().unwrap()
        cargo_toml_text.push_str(
            format!("

[dependencies.{struct_name}] 
path = \"{src_dir}\"", 
                struct_name = struct_src_dir.filename_str().unwrap(), 
                src_dir = struct_src_dir.as_str().unwrap()
            ).as_slice()
        );
    } 
    
    
    let cargo_toml_path = hierarchy::get_state_src_dir().join("Cargo.toml");

    println!("Creating new Cargo.toml");
    let mut cargo_toml_file = File::create(&cargo_toml_path);
    cargo_toml_file.write_str(cargo_toml_text.as_slice()).unwrap();
    cargo_toml_file.flush().unwrap();
}
